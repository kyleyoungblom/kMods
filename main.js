/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KModsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  // Cursor management
  enableCursorHiding: true,
  hideCursorOnOpen: true,
  // CSS Snippets manager
  enableSnippetsManager: true,
  showSnippetsStatusBar: true,
  snippetsDisabledByBulkToggle: [],
  // Bulk plugin toggle
  enableBulkPluginToggle: true,
  pluginsDisabledByBulkToggle: [],
  // Banners
  enableBanners: true,
  bannerHeight: 200,
  bannerFrontmatterField: "banner"
};
var KModsPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.statusBarItem = null;
  }
  async onload() {
    await this.loadSettings();
    if (this.settings.enableCursorHiding) {
      this.registerEvent(
        this.app.workspace.on("file-open", (file) => {
          if (this.settings.hideCursorOnOpen && file) {
            this.hideCursorInActiveEditor();
          }
        })
      );
      this.registerDomEvent(document, "keydown", (e) => {
        if (e.key === "Escape" || e.code === "Escape") {
          const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
          if (!activeView)
            return;
          const contentEl = activeView.contentEl;
          const editorEl = contentEl.querySelector(".cm-editor");
          const contentDOM = contentEl.querySelector(".cm-content");
          if (contentDOM && (document.activeElement === contentDOM || (editorEl && editorEl.contains(document.activeElement)))) {
            e.preventDefault();
            e.stopPropagation();
            contentDOM.blur();
            if (editorEl) {
              editorEl.blur();
            }
            activeView.editor.blur();
          }
        }
      }, true);
    }
    if (this.settings.enableSnippetsManager && this.settings.showSnippetsStatusBar) {
      this.addSnippetsStatusBar();
    }
    if (this.settings.enableBulkPluginToggle) {
      const observer = new MutationObserver(() => {
        this.addBulkPluginToggleButton();
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      setTimeout(() => this.addBulkPluginToggleButton(), 1e3);
      setTimeout(() => this.addBulkPluginToggleButton(), 3e3);
    }
    if (this.settings.enableBanners) {
      this.initializeBanners();
    }
    this.addSettingTab(new KModsSettingTab(this.app, this));
  }
  onunload() {
    if (this.statusBarItem) {
      this.statusBarItem.remove();
    }
  }
  addSnippetsStatusBar() {
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.addClass("kmods-snippets-status-bar");
    this.statusBarItem.setText("CSS Snippets");
    this.statusBarItem.addEventListener("click", (e) => {
      this.showSnippetsMenu(e);
    });
  }
  showSnippetsMenu(e) {
    const modal = new SnippetsModal(this.app, this);
    modal.open();
  }
  hideCursorInActiveEditor() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return;
    const attemptBlur = (attempt = 0) => {
      var _a, _b, _c;
      if (attempt > 5)
        return;
      const editor = activeView.editor;
      const editorElement = (_c = (_b = (_a = activeView.editMode) == null ? void 0 : _a.editor) == null ? void 0 : _b.cm) == null ? void 0 : _c.contentDOM;
      if (editor && editorElement) {
        if (document.activeElement === editorElement || editorElement.contains(document.activeElement)) {
          editorElement.blur();
          return;
        }
      }
      const delay = attempt === 0 ? 50 : 100 * Math.pow(1.5, attempt - 1);
      setTimeout(() => attemptBlur(attempt + 1), delay);
    };
    attemptBlur();
  }
  addBulkPluginToggleButton() {
    const settingsTab = document.querySelector(".community-plugins") || document.querySelector('[data-id="community-plugins"]') || document.querySelector(".vertical-tab-content");
    if (!settingsTab) {
      return;
    }
    if (document.querySelector(".kmods-bulk-toggle-button")) {
      return;
    }
    const headings = Array.from(document.querySelectorAll(".setting-item-heading"));
    const installedPluginsHeading = headings.find(
      (heading) => {
        var _a;
        return (_a = heading.textContent) == null ? void 0 : _a.toLowerCase().includes("installed");
      }
    );
    if (!installedPluginsHeading) {
      return;
    }
    const buttonContainer = document.createElement("div");
    buttonContainer.classList.add("kmods-bulk-toggle-container");
    buttonContainer.style.display = "inline-block";
    buttonContainer.style.marginLeft = "12px";
    installedPluginsHeading.appendChild(buttonContainer);
    const button = new import_obsidian.ButtonComponent(buttonContainer);
    button.buttonEl.classList.add("kmods-bulk-toggle-button");
    const anyPluginsDisabled = this.settings.pluginsDisabledByBulkToggle.length > 0;
    button.setButtonText(anyPluginsDisabled ? "Re-enable all plugins" : "Disable all plugins (except kMods)");
    button.onClick(async () => {
      await this.toggleAllPlugins();
      buttonContainer.remove();
      this.addBulkPluginToggleButton();
    });
  }
  async toggleAllPlugins() {
    const plugins = this.app.plugins;
    if (this.settings.pluginsDisabledByBulkToggle.length > 0) {
      for (const pluginId of this.settings.pluginsDisabledByBulkToggle) {
        await plugins.enablePlugin(pluginId);
      }
      this.settings.pluginsDisabledByBulkToggle = [];
      await this.saveSettings();
    } else {
      const enabledPlugins = [];
      const manifests = plugins.manifests;
      for (const pluginId in manifests) {
        if (pluginId === "kMods")
          continue;
        if (plugins.enabledPlugins.has(pluginId)) {
          enabledPlugins.push(pluginId);
        }
      }
      for (const pluginId of enabledPlugins) {
        await plugins.disablePlugin(pluginId);
      }
      this.settings.pluginsDisabledByBulkToggle = enabledPlugins;
      await this.saveSettings();
    }
    await plugins.saveData();
  }
  initializeBanners() {
    this.registerMarkdownPostProcessor((el, ctx) => {
      this.processBannerInReadingView(el, ctx);
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.updateBanner();
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.updateBanner();
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView && activeView.file === file) {
          setTimeout(() => this.updateBanner(), 100);
        }
      })
    );
    this.addCommand({
      id: "add-banner",
      name: "Add banner to current note",
      callback: () => {
        new AddBannerModal(this.app, this).open();
      }
    });
  }
  async updateBanner() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view || !view.file)
      return;
    const contentEl = view.contentEl;
    const cache = this.app.metadataCache.getFileCache(view.file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    const bannerField = this.settings.bannerFrontmatterField;
    let banner = frontmatter ? frontmatter[bannerField] : null;
    if (!banner) {
      const existingBanner = contentEl.querySelector(".kmods-banner-container");
      if (existingBanner) {
        existingBanner.remove();
      }
      const cmSizer2 = contentEl.querySelector(".cm-sizer");
      if (cmSizer2) {
        cmSizer2.style.paddingTop = "";
      }
      return;
    }
    if (banner.startsWith("[[") && banner.endsWith("]]")) {
      const linkText = banner.slice(2, -2);
      const file = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
      if (file) {
        banner = this.app.vault.adapter.getResourcePath(file.path);
      }
    }
    const cmSizer = contentEl.querySelector(".cm-sizer");
    if (!cmSizer)
      return;
    let bannerContainer = cmSizer.querySelector(":scope > .kmods-banner-container");
    if (!bannerContainer) {
      bannerContainer = document.createElement("div");
      bannerContainer.className = "kmods-banner-container";
      cmSizer.insertBefore(bannerContainer, cmSizer.firstChild);
    }
    const bannerHeight = frontmatter[`${bannerField}_height`] || this.settings.bannerHeight;
    cmSizer.style.paddingTop = `${bannerHeight + 20}px`;
    const bannerY = frontmatter[`${bannerField}_y`] || 0.5;
    bannerContainer.innerHTML = "";
    bannerContainer.style.height = `${bannerHeight}px`;
    const bannerDiv = document.createElement("div");
    bannerDiv.className = "kmods-banner";
    bannerDiv.style.height = `${bannerHeight}px`;
    const img = document.createElement("img");
    img.className = "kmods-banner-image";
    img.src = banner;
    img.alt = "";
    img.style.objectPosition = `50% ${bannerY * 100}%`;
    let isDragging = false;
    let startY = 0;
    let startPos = bannerY;
    img.addEventListener("mousedown", (e) => {
      if (e.button === 0) {
        isDragging = true;
        startY = e.clientY;
        startPos = bannerY;
        e.preventDefault();
      }
    });
    document.addEventListener("mousemove", (e) => {
      if (isDragging) {
        const deltaY = e.clientY - startY;
        const newPos = Math.max(0, Math.min(1, startPos - deltaY / bannerHeight));
        img.style.objectPosition = `50% ${newPos * 100}%`;
      }
    });
    document.addEventListener("mouseup", async (e) => {
      if (isDragging) {
        isDragging = false;
        const deltaY = e.clientY - startY;
        const newPos = Math.max(0, Math.min(1, startPos - deltaY / bannerHeight));
        if (view.file) {
          await this.app.fileManager.processFrontMatter(view.file, (fm) => {
            fm[`${bannerField}_y`] = newPos;
          });
        }
      }
    });
    img.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      const menu = new import_obsidian.Menu();
      menu.addItem((item) => {
        item.setTitle("Change banner image").setIcon("image").onClick(() => {
          new ChangeBannerModal(this.app, this, view.file).open();
        });
      });
      menu.addItem((item) => {
        item.setTitle("Remove banner").setIcon("trash").onClick(async () => {
          if (view.file) {
            await this.app.fileManager.processFrontMatter(view.file, (fm) => {
              delete fm[bannerField];
              delete fm[`${bannerField}_y`];
              delete fm[`${bannerField}_height`];
            });
            await this.updateBanner();
          }
        });
      });
      menu.showAtMouseEvent(e);
    });
    bannerDiv.appendChild(img);
    bannerContainer.appendChild(bannerDiv);
  }
  processBannerInReadingView(el, ctx) {
    const frontmatterEl = el.querySelector("pre.frontmatter");
    if (!frontmatterEl)
      return;
    const file = this.app.vault.getAbstractFileByPath(ctx.sourcePath);
    if (!file)
      return;
    const cache = this.app.metadataCache.getFileCache(file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    if (!frontmatter)
      return;
    const bannerField = this.settings.bannerFrontmatterField;
    const banner = frontmatter[bannerField];
    if (!banner)
      return;
    this.renderBanner(el, banner, frontmatter);
  }
  renderBanner(container, bannerSrc, frontmatter) {
    const bannerField = this.settings.bannerFrontmatterField;
    const wrapper = container.createDiv({ cls: "kmods-banner-wrapper" });
    const bannerEl = wrapper.createDiv({ cls: "kmods-banner" });
    bannerEl.style.setProperty("--banner-height", `${this.settings.bannerHeight}px`);
    const img = bannerEl.createEl("img", {
      cls: "kmods-banner-image",
      attr: {
        src: bannerSrc,
        alt: "Banner"
      }
    });
    const bannerY = frontmatter[`${bannerField}_y`];
    if (bannerY !== void 0) {
      img.style.objectPosition = `50% ${bannerY * 100}%`;
    }
    container.insertBefore(wrapper, container.firstChild);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SnippetsModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "CSS Snippets" });
    const customCss = this.app.customCss;
    if (!customCss) {
      contentEl.createEl("p", { text: "CSS customization not available" });
      return;
    }
    const currentSnippets = customCss.snippets || [];
    if (currentSnippets.length === 0) {
      contentEl.createEl("p", { text: "No CSS snippets found" });
      return;
    }
    const bulkToggleSetting = new import_obsidian.Setting(contentEl).setName("Toggle all snippets").setClass("kmods-bulk-snippet-toggle");
    const anySnippetsDisabled = this.plugin.settings.snippetsDisabledByBulkToggle.length > 0;
    bulkToggleSetting.addButton(
      (button) => button.setButtonText(anySnippetsDisabled ? "Re-enable all snippets" : "Disable all snippets").onClick(async () => {
        await this.toggleAllSnippets();
        this.onOpen();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Open snippets folder").setDesc("Open the CSS snippets folder in your file manager").addButton(
      (button) => button.setButtonText("Open Folder").onClick(async () => {
        const snippetsPath = `${this.app.vault.configDir}/snippets`;
        const basePath = this.app.vault.adapter.getBasePath();
        const absolutePath = `${basePath}/${snippetsPath}`;
        require("electron").shell.openPath(absolutePath);
      })
    );
    contentEl.createEl("hr", { cls: "kmods-snippets-separator" });
    const snippetsContainer = contentEl.createDiv({ cls: "kmods-snippets-container" });
    currentSnippets.forEach((snippet) => {
      new import_obsidian.Setting(snippetsContainer).setName(snippet).addToggle(
        (toggle) => {
          var _a;
          return toggle.setValue(((_a = customCss.enabledSnippets) == null ? void 0 : _a.has(snippet)) || false).onChange((value) => {
            customCss.setCssEnabledStatus(snippet, value);
          });
        }
      );
    });
  }
  async toggleAllSnippets() {
    var _a;
    const customCss = this.app.customCss;
    if (this.plugin.settings.snippetsDisabledByBulkToggle.length > 0) {
      for (const snippet of this.plugin.settings.snippetsDisabledByBulkToggle) {
        customCss.setCssEnabledStatus(snippet, true);
      }
      this.plugin.settings.snippetsDisabledByBulkToggle = [];
      await this.plugin.saveSettings();
    } else {
      const enabledSnippets = [];
      const currentSnippets = customCss.snippets || [];
      for (const snippet of currentSnippets) {
        if ((_a = customCss.enabledSnippets) == null ? void 0 : _a.has(snippet)) {
          enabledSnippets.push(snippet);
        }
      }
      for (const snippet of enabledSnippets) {
        customCss.setCssEnabledStatus(snippet, false);
      }
      this.plugin.settings.snippetsDisabledByBulkToggle = enabledSnippets;
      await this.plugin.saveSettings();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AddBannerModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.selectedFile = "";
    this.plugin = plugin;
    this.bannerHeight = plugin.settings.bannerHeight;
    this.textInput = null;
    this.bannerAdded = false;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Add Banner to Note" });
    new import_obsidian.Setting(contentEl).setName("Banner image").setDesc("Enter an image path or use [[wikilink]] format").addText((text) => {
      this.textInput = text;
      text.setPlaceholder("[[image.png]] or path/to/image.png").setValue(this.selectedFile).onChange((value) => {
        this.selectedFile = value;
        this.showPreview();
      });
      text.inputEl.style.width = "100%";
    }).addButton((button) => {
      button.setButtonText("Browse").onClick(() => {
        this.openFilePicker();
      });
    });
    new import_obsidian.Setting(contentEl).setName("Banner height").setDesc("Height of the banner in pixels").addText((text) => {
      text.setPlaceholder("200").setValue(String(this.bannerHeight)).onChange((value) => {
        const height = parseInt(value);
        if (!isNaN(height) && height > 0) {
          this.bannerHeight = height;
          this.showPreview();
        }
      });
      text.inputEl.type = "number";
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
      this.close();
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Add Banner").setCta().onClick(async () => {
      await this.addBanner();
    });
    if (this.selectedFile) {
      this.showPreview();
    }
  }
  showPreview() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return;
    const contentEl = activeView.contentEl;
    const cmSizer = contentEl.querySelector(".cm-sizer");
    if (!cmSizer)
      return;
    let bannerSrc = this.selectedFile;
    if (!bannerSrc) {
      this.removePreview();
      return;
    }
    if (bannerSrc.startsWith("[[") && bannerSrc.endsWith("]]")) {
      const linkText = bannerSrc.slice(2, -2);
      const file = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
      if (file) {
        bannerSrc = this.app.vault.adapter.getResourcePath(file.path);
      } else {
        return;
      }
    }
    let bannerContainer = cmSizer.querySelector(":scope > .kmods-banner-container.kmods-preview");
    if (!bannerContainer) {
      bannerContainer = document.createElement("div");
      bannerContainer.className = "kmods-banner-container kmods-preview";
      cmSizer.insertBefore(bannerContainer, cmSizer.firstChild);
    }
    cmSizer.style.paddingTop = `${this.bannerHeight + 20}px`;
    bannerContainer.innerHTML = "";
    bannerContainer.style.height = `${this.bannerHeight}px`;
    const bannerDiv = document.createElement("div");
    bannerDiv.className = "kmods-banner";
    bannerDiv.style.height = `${this.bannerHeight}px`;
    const img = document.createElement("img");
    img.className = "kmods-banner-image";
    img.src = bannerSrc;
    img.alt = "";
    img.style.objectPosition = "50% 50%";
    bannerDiv.appendChild(img);
    bannerContainer.appendChild(bannerDiv);
  }
  removePreview() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return;
    const contentEl = activeView.contentEl;
    const preview = contentEl.querySelector(".kmods-banner-container.kmods-preview");
    if (preview) {
      preview.remove();
    }
    const cmSizer = contentEl.querySelector(".cm-sizer");
    if (cmSizer) {
      cmSizer.style.paddingTop = "";
    }
  }
  async openFilePicker() {
    const imageFiles = this.app.vault.getFiles().filter((file) => {
      const ext = file.extension.toLowerCase();
      return ["jpg", "jpeg", "png", "gif", "bmp", "svg", "webp"].includes(ext);
    });
    const suggester = new ImageFileSuggester(this.app, imageFiles, (file) => {
      this.selectedFile = `[[${file.path}]]`;
      this.onOpen();
    });
    suggester.open();
  }
  async addBanner() {
    if (!this.selectedFile) {
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView || !activeView.file) {
      return;
    }
    const bannerField = this.plugin.settings.bannerFrontmatterField;
    await this.app.fileManager.processFrontMatter(activeView.file, (fm) => {
      fm[bannerField] = this.selectedFile;
      fm[`${bannerField}_height`] = this.bannerHeight;
    });
    this.bannerAdded = true;
    this.close();
  }
  onClose() {
    if (!this.bannerAdded) {
      this.removePreview();
    }
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ChangeBannerModal = class extends import_obsidian.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.selectedFile = "";
    this.plugin = plugin;
    this.file = file;
    this.textInput = null;
    this.bannerChanged = false;
    this.originalBannerSrc = null;
    this.originalBannerY = null;
    this.originalPadding = null;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.storeOriginalBanner();
    const cache = this.app.metadataCache.getFileCache(this.file);
    const frontmatter = cache == null ? void 0 : cache.frontmatter;
    const bannerField = this.plugin.settings.bannerFrontmatterField;
    if (frontmatter && frontmatter[bannerField]) {
      this.selectedFile = frontmatter[bannerField];
      this.bannerHeight = frontmatter[`${bannerField}_height`] || this.plugin.settings.bannerHeight;
    } else {
      this.bannerHeight = this.plugin.settings.bannerHeight;
    }
    contentEl.createEl("h2", { text: "Change Banner Image" });
    new import_obsidian.Setting(contentEl).setName("Banner image").setDesc("Enter an image path or use [[wikilink]] format").addText((text) => {
      this.textInput = text;
      text.setPlaceholder("[[image.png]] or path/to/image.png").setValue(this.selectedFile).onChange((value) => {
        this.selectedFile = value;
        this.showPreview();
      });
      text.inputEl.style.width = "100%";
    }).addButton((button) => {
      button.setButtonText("Browse").onClick(() => {
        this.openFilePicker();
      });
    });
    new import_obsidian.Setting(contentEl).setName("Banner height").setDesc("Height of the banner in pixels").addText((text) => {
      text.setPlaceholder("200").setValue(String(this.bannerHeight)).onChange((value) => {
        const height = parseInt(value);
        if (!isNaN(height) && height > 0) {
          this.bannerHeight = height;
          this.showPreview();
        }
      });
      text.inputEl.type = "number";
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
      this.close();
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Change Banner").setCta().onClick(async () => {
      await this.changeBanner();
    });
  }
  storeOriginalBanner() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return;
    const contentEl = activeView.contentEl;
    const cmSizer = contentEl.querySelector(".cm-sizer");
    const existingBanner = cmSizer == null ? void 0 : cmSizer.querySelector(":scope > .kmods-banner-container");
    if (existingBanner) {
      const img = existingBanner.querySelector(".kmods-banner-image");
      this.originalBannerSrc = img ? img.src : null;
      this.originalBannerY = img ? img.style.objectPosition : null;
      this.originalPadding = cmSizer ? cmSizer.style.paddingTop : null;
      this.originalHeight = existingBanner.style.height;
    }
  }
  showPreview() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return;
    const contentEl = activeView.contentEl;
    const cmSizer = contentEl.querySelector(".cm-sizer");
    if (!cmSizer)
      return;
    let bannerSrc = this.selectedFile;
    if (!bannerSrc) {
      return;
    }
    if (bannerSrc.startsWith("[[") && bannerSrc.endsWith("]]")) {
      const linkText = bannerSrc.slice(2, -2);
      const file = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
      if (file) {
        bannerSrc = this.app.vault.adapter.getResourcePath(file.path);
      } else {
        return;
      }
    }
    let bannerContainer = cmSizer.querySelector(":scope > .kmods-banner-container");
    if (!bannerContainer) {
      bannerContainer = document.createElement("div");
      bannerContainer.className = "kmods-banner-container";
      cmSizer.insertBefore(bannerContainer, cmSizer.firstChild);
    }
    cmSizer.style.paddingTop = `${this.bannerHeight + 20}px`;
    bannerContainer.innerHTML = "";
    bannerContainer.style.height = `${this.bannerHeight}px`;
    const bannerDiv = document.createElement("div");
    bannerDiv.className = "kmods-banner";
    bannerDiv.style.height = `${this.bannerHeight}px`;
    const img = document.createElement("img");
    img.className = "kmods-banner-image";
    img.src = bannerSrc;
    img.alt = "";
    img.style.objectPosition = "50% 50%";
    bannerDiv.appendChild(img);
    bannerContainer.appendChild(bannerDiv);
  }
  restoreOriginalBanner() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return;
    const contentEl = activeView.contentEl;
    const cmSizer = contentEl.querySelector(".cm-sizer");
    if (!cmSizer)
      return;
    const bannerContainer = cmSizer.querySelector(":scope > .kmods-banner-container");
    if (this.originalBannerSrc && bannerContainer) {
      const img = bannerContainer.querySelector(".kmods-banner-image");
      if (img) {
        img.src = this.originalBannerSrc;
        if (this.originalBannerY) {
          img.style.objectPosition = this.originalBannerY;
        }
      }
      if (this.originalHeight) {
        bannerContainer.style.height = this.originalHeight;
        const bannerDiv = bannerContainer.querySelector(".kmods-banner");
        if (bannerDiv) {
          bannerDiv.style.height = this.originalHeight;
        }
      }
      if (this.originalPadding) {
        cmSizer.style.paddingTop = this.originalPadding;
      }
    }
  }
  async openFilePicker() {
    const imageFiles = this.app.vault.getFiles().filter((file) => {
      const ext = file.extension.toLowerCase();
      return ["jpg", "jpeg", "png", "gif", "bmp", "svg", "webp"].includes(ext);
    });
    const suggester = new ImageFileSuggester(this.app, imageFiles, (file) => {
      this.selectedFile = `[[${file.path}]]`;
      this.onOpen();
    });
    suggester.open();
  }
  async changeBanner() {
    if (!this.selectedFile) {
      return;
    }
    const bannerField = this.plugin.settings.bannerFrontmatterField;
    await this.app.fileManager.processFrontMatter(this.file, (fm) => {
      fm[bannerField] = this.selectedFile;
      fm[`${bannerField}_height`] = this.bannerHeight;
    });
    this.bannerChanged = true;
    this.close();
  }
  onClose() {
    if (!this.bannerChanged) {
      this.restoreOriginalBanner();
    }
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ImageFileSuggester = class extends import_obsidian.Modal {
  constructor(app, files, onSelect) {
    super(app);
    this.filterText = "";
    this.files = files;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("kmods-file-suggester");
    contentEl.createEl("h3", { text: "Select Banner Image" });
    const searchInput = contentEl.createEl("input", {
      type: "text",
      placeholder: "Search for an image..."
    });
    searchInput.style.width = "100%";
    searchInput.style.marginBottom = "10px";
    searchInput.style.padding = "8px";
    const fileList = contentEl.createDiv({ cls: "kmods-file-list" });
    fileList.style.maxHeight = "400px";
    fileList.style.overflowY = "auto";
    const renderFiles = (filter = "") => {
      fileList.empty();
      const filteredFiles = this.files.filter(
        (file) => file.path.toLowerCase().includes(filter.toLowerCase())
      );
      if (filteredFiles.length === 0) {
        fileList.createEl("p", { text: "No images found" });
        return;
      }
      filteredFiles.forEach((file) => {
        const fileItem = fileList.createDiv({ cls: "kmods-file-item" });
        fileItem.style.padding = "8px";
        fileItem.style.cursor = "pointer";
        fileItem.style.borderBottom = "1px solid var(--background-modifier-border)";
        fileItem.setText(file.path);
        fileItem.addEventListener("mouseenter", () => {
          fileItem.style.backgroundColor = "var(--background-modifier-hover)";
        });
        fileItem.addEventListener("mouseleave", () => {
          fileItem.style.backgroundColor = "";
        });
        fileItem.addEventListener("click", () => {
          this.onSelect(file);
          this.close();
        });
      });
    };
    renderFiles();
    searchInput.addEventListener("input", (e) => {
      this.filterText = e.target.value;
      renderFiles(this.filterText);
    });
    searchInput.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var KModsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "kMods Settings" });
    const manifest = this.plugin.manifest;
    if (manifest && manifest.version) {
      const versionEl = containerEl.createDiv({ cls: "setting-item-description" });
      versionEl.style.marginTop = "-10px";
      versionEl.style.marginBottom = "20px";
      versionEl.style.opacity = "0.7";
      versionEl.setText(`Version ${manifest.version}`);
    }
    containerEl.createEl("p", {
      text: "A collection of miscellaneous tweaks for Obsidian. Each feature can be enabled or disabled independently.",
      cls: "setting-item-description"
    });
    this.addSectionHeader(containerEl, "Cursor Management");
    new import_obsidian.Setting(containerEl).setName("Enable cursor hiding").setDesc("Turn this feature on or off. Requires reload to take effect.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableCursorHiding).onChange(async (value) => {
      this.plugin.settings.enableCursorHiding = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Hide cursor on file open").setDesc("Removes the cursor when opening a document to preserve live preview on the first line.").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideCursorOnOpen).onChange(async (value) => {
      this.plugin.settings.hideCursorOnOpen = value;
      await this.plugin.saveSettings();
    }));
    this.addSectionHeader(containerEl, "CSS Snippets Manager");
    new import_obsidian.Setting(containerEl).setName("Enable snippets manager").setDesc("Turn this feature on or off. Requires reload to take effect.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSnippetsManager).onChange(async (value) => {
      this.plugin.settings.enableSnippetsManager = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show CSS Snippets in status bar").setDesc("Adds a status bar item to quickly toggle CSS snippets on/off.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSnippetsStatusBar).onChange(async (value) => {
      this.plugin.settings.showSnippetsStatusBar = value;
      await this.plugin.saveSettings();
    }));
    this.addSectionHeader(containerEl, "Bulk Plugin Toggle");
    new import_obsidian.Setting(containerEl).setName("Enable bulk plugin toggle").setDesc("Adds a button to the Community Plugins settings to disable/enable all plugins at once. Requires reload to take effect.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableBulkPluginToggle).onChange(async (value) => {
      this.plugin.settings.enableBulkPluginToggle = value;
      await this.plugin.saveSettings();
    }));
    this.addSectionHeader(containerEl, "Banners");
    new import_obsidian.Setting(containerEl).setName("Enable banners").setDesc("Display banner images at the top of notes. Requires reload to take effect.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableBanners).onChange(async (value) => {
      this.plugin.settings.enableBanners = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Banner height").setDesc("Height of banner images in pixels.").addSlider((slider) => slider.setLimits(100, 500, 10).setValue(this.plugin.settings.bannerHeight).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.bannerHeight = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Frontmatter field name").setDesc('The frontmatter field to use for banner images (e.g., "banner").').addText((text) => text.setPlaceholder("banner").setValue(this.plugin.settings.bannerFrontmatterField).onChange(async (value) => {
      this.plugin.settings.bannerFrontmatterField = value || "banner";
      await this.plugin.saveSettings();
    }));
  }
  addSectionHeader(containerEl, title) {
    containerEl.createEl("h3", {
      text: title,
      cls: "kmods-section-header"
    });
  }
};
